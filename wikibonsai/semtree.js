const fs = require("fs");
const path = require("path");
const glob = require("glob");
const matter = require('gray-matter');
const semtree = require('semtree');
const constants = require('./const');


module.exports = function buildBonsai() {
  // init vars
  const opts = {
    virtualTrunk: true,
    // semtree options here...
    // https://github.com/wikibonsai/semtree?tab=readme-ov-file#options
  };
  const bonsaiText = {}; // { filename: content } hash
  // build 'bonsaiText' hash
  const files = glob.sync(constants.INDEX_GLOB, {});
  files.forEach((file) => {
    const content = fs.readFileSync(file, { encoding: 'utf8' });
    const yamlData = matter(content);
    const basename = path.basename(file, '.md');
    const cleanContent = yamlData.content.replace(/^\n*/, '');
    bonsaiText[basename] = cleanContent;
  });
  let bonsai = 'uninitialized bonsai';
  try {
    // build bonsai tree data struct
    // semtree expects the root key to match the basenames used in `bonsaiText`.
    // Our `bonsaiText` keys are produced via `path.basename(file, '.md')`, so
    // pass the basename of the configured root filename rather than the full
    // path.
    const rootKey = path.basename(constants.ROOT_FNAME, '.md');
    bonsai = semtree.create(rootKey, bonsaiText, opts);
    // Validate result before using it; semtree may return undefined or an
    // invalid structure when lint errors are present (duplicate names, or
    // orphan trunks). Give a clearer error instead of letting the caller hit
    // an unhelpful TypeError when accessing `bonsai.nodes`.
    if (!bonsai || !Array.isArray(bonsai.nodes)) {
      console.error('semtree.create returned invalid bonsai:', bonsai);
      throw new Error('Invalid bonsai tree generated by semtree; see earlier logs for details.');
    }
    const files = glob.sync(constants.ENTRIES_GLOB, {});
    for (let node of bonsai.nodes) {
      const file = files.find((file) => path.basename(file, '.md') == node.text);
      if (file !== undefined) {
        node.url = '/entries/' + path.basename(file, '.md');
      }
    }
    console.log('bonsai: \n'
      + '\n---\n'
      + 'root: ' + bonsai.root
      + '\n---\n'
      + 'trunk: ' + bonsai.trunk
      + '\n---\n'
      + 'petioleMap: ' + JSON.stringify(bonsai.petioleMap)
      + '\n---\n'
      + 'orphans: ' + bonsai.orphans
      + '\n---\n'
      + 'nodes: ' + JSON.stringify(bonsai.nodes)
      + '\n---\n'
    );
    return bonsai;
  } catch (e) {
    // Log the original error and return a safe fallback bonsai structure so
    // the rest of the Eleventy build can continue without throwing a
    // TypeError when accessing `bonsai.nodes`.
    console.error('semtree.create error:', e, bonsai);
    return {
      root: null,
      trunk: null,
      petioleMap: {},
      orphans: [],
      nodes: [],
    };
  }
}
